workflows:
  android-apk:
    name: Android Release (APK + AAB) - GaBoLP
    max_build_duration: 60
    environment:
      flutter: stable

    cache:
      cache_paths:
        - $HOME/.pub-cache
        - $HOME/.gradle/caches
        - $HOME/.gradle/wrapper

    scripts:
      - name: Preparar proyecto (crear android si falta)
        script: |
          set -e
          if [ ! -d "android" ]; then
            TMPDIR="$(mktemp -d)"
            cp -R lib "$TMPDIR/lib"
            if [ -d "assets" ]; then cp -R assets "$TMPDIR/assets"; fi
            cp pubspec.yaml "$TMPDIR/pubspec.yaml"

            flutter create . --platforms=android --org com.gabolp.app

            rm -f pubspec.yaml
            cp "$TMPDIR/pubspec.yaml" pubspec.yaml

            rm -rf lib
            cp -R "$TMPDIR/lib" lib

            if [ -d "$TMPDIR/assets" ]; then
              rm -rf assets
              cp -R "$TMPDIR/assets" assets
            fi
          fi

      - name: Forzar permisos INTERNET + CAMERA en AndroidManifest MAIN
        script: |
          set -e
          MANIFEST="android/app/src/main/AndroidManifest.xml"
          echo "Usando: $MANIFEST"
          if [ ! -f "$MANIFEST" ]; then
            echo "ERROR: No existe $MANIFEST"
            echo "Manifests encontrados:"
            find android -name AndroidManifest.xml -print || true
            exit 1
          fi

          insert_perm () {
            local PERM="$1"
            if grep -q "$PERM" "$MANIFEST"; then
              echo "$PERM ya estaba en el MAIN manifest."
            else
              echo "Insertando $PERM en el MAIN manifest..."
              perl -0777 -i -pe "s/(<manifest[^>]*>)/\$1\n    <uses-permission android:name=\"$PERM\"\/>/s" "$MANIFEST"
            fi
          }

          insert_feature () {
            local FEATURE="$1"
            if grep -q "$FEATURE" "$MANIFEST"; then
              echo "$FEATURE ya estaba en el MAIN manifest."
            else
              echo "Insertando uses-feature $FEATURE..."
              perl -0777 -i -pe "s/(<manifest[^>]*>)/\$1\n    <uses-feature android:name=\"$FEATURE\" android:required=\"false\"\/>/s" "$MANIFEST"
            fi
          }

          insert_perm "android.permission.INTERNET"
          insert_perm "android.permission.CAMERA"
          insert_feature "android.hardware.camera"

          echo "Chequeo MAIN manifest:"
          grep -n "android.permission.INTERNET" "$MANIFEST" || true
          grep -n "android.permission.CAMERA" "$MANIFEST" || true
          head -n 30 "$MANIFEST"

      - name: Fix ML Kit OCR (R8) - evitar Missing classes
        script: |
          set -e

          # google_mlkit_text_recognition referencia opciones para varios alfabetos.
          # En release con R8, si esos módulos no están, puede fallar con "Missing class ...TextRecognizerOptions".
          # Solución robusta: (1) agregar los artefactos de ML Kit faltantes y (2) migrar kotlinOptions.jvmTarget
          # a compilerOptions (Kotlin 2.x) SIN romper el build.gradle.kts.

          python3 - <<'PY'
          from pathlib import Path
          import re

          def add_deps_kts(s: str) -> str:
              deps = [
                  'implementation("com.google.mlkit:text-recognition-chinese:16.0.0")',
                  'implementation("com.google.mlkit:text-recognition-japanese:16.0.0")',
                  'implementation("com.google.mlkit:text-recognition-korean:16.0.0")',
                  'implementation("com.google.mlkit:text-recognition-devanagari:16.0.0")',
              ]
              if 'text-recognition-korean' in s:
                  return s
              m = re.search(r"dependencies\s*\{\s*", s)
              if not m:
                  return s
              insert = "\n" + "\n".join(["        " + d for d in deps]) + "\n"
              return s[:m.end()] + insert + s[m.end():]

          def add_deps_groovy(s: str) -> str:
              deps = [
                  "implementation 'com.google.mlkit:text-recognition-chinese:16.0.0'",
                  "implementation 'com.google.mlkit:text-recognition-japanese:16.0.0'",
                  "implementation 'com.google.mlkit:text-recognition-korean:16.0.0'",
                  "implementation 'com.google.mlkit:text-recognition-devanagari:16.0.0'",
              ]
              if 'text-recognition-korean' in s:
                  return s
              m = re.search(r"dependencies\s*\{\s*", s)
              if not m:
                  return s
              insert = "\n" + "\n".join(["    " + d for d in deps]) + "\n"
              return s[:m.end()] + insert + s[m.end():]

          def remove_named_block(s: str, name: str) -> str:
              # remove blocks like: name { ... }
              while True:
                  idx = s.find(name)
                  if idx == -1:
                      return s
                  brace = s.find('{', idx)
                  if brace == -1:
                      return s
                  # ensure it's actually "name {" (allow whitespace)
                  head = s[idx:brace].strip()
                  if head != name:
                      # false positive (e.g. comment)
                      nxt = s.find(name, idx + len(name))
                      if nxt == -1:
                          return s
                      idx = nxt
                      continue
                  depth = 0
                  end = None
                  for j in range(brace, len(s)):
                      if s[j] == '{':
                          depth += 1
                      elif s[j] == '}':
                          depth -= 1
                          if depth == 0:
                              end = j + 1
                              break
                  if end is None:
                      return s
                  s = s[:idx] + "\n" + s[end:]

          def ensure_compiler_options_kts(s: str) -> str:
              # Remove deprecated kotlinOptions blocks (Kotlin 2.x deprecation)
              s2 = remove_named_block(s, 'kotlinOptions')
              s = s2
              # Ensure compilerOptions exists
              if 'compilerOptions' in s and 'JvmTarget.JVM_17' in s:
                  return s
              # If there's already a top-level kotlin { }, insert compilerOptions before its closing brace.
              k = s.find('kotlin {')
              if k != -1:
                  brace = s.find('{', k)
                  depth = 0
                  for j in range(brace, len(s)):
                      if s[j] == '{':
                          depth += 1
                      elif s[j] == '}':
                          depth -= 1
                          if depth == 0:
                              ins = "\n    compilerOptions {\n        jvmTarget.set(org.jetbrains.kotlin.gradle.dsl.JvmTarget.JVM_17)\n    }\n"
                              return s[:j] + ins + s[j:]
              # Otherwise append a clean block
              return s + "\n\nkotlin {\n    compilerOptions {\n        jvmTarget.set(org.jetbrains.kotlin.gradle.dsl.JvmTarget.JVM_17)\n    }\n}\n"

          kts = Path('android/app/build.gradle.kts')
          groovy = Path('android/app/build.gradle')

          if kts.exists():
              s = kts.read_text(encoding='utf-8')
              s = add_deps_kts(s)
              s = ensure_compiler_options_kts(s)
              kts.write_text(s, encoding='utf-8')
              print('OK: patched build.gradle.kts')
          elif groovy.exists():
              s = groovy.read_text(encoding='utf-8')
              s = add_deps_groovy(s)
              groovy.write_text(s, encoding='utf-8')
              print('OK: patched build.gradle')
          else:
              print('WARN: no app gradle file found')
          PY

          # Suprimir warnings si R8/Proguard los muestra por módulos opcionales
          PROGUARD_FILE="android/app/proguard-rules.pro"
          mkdir -p "$(dirname "$PROGUARD_FILE")"
          touch "$PROGUARD_FILE"
          if ! grep -q "MLKIT_TEXT_RECOGNITION_R8" "$PROGUARD_FILE"; then
            printf '%s\n' \
              '# MLKIT_TEXT_RECOGNITION_R8' \
              '-dontwarn com.google.mlkit.vision.text.chinese.**' \
              '-dontwarn com.google.mlkit.vision.text.japanese.**' \
              '-dontwarn com.google.mlkit.vision.text.korean.**' \
              '-dontwarn com.google.mlkit.vision.text.devanagari.**' \
              >> "$PROGUARD_FILE"
          fi
      - name: Instalar dependencias
        script: |
          flutter pub get

      - name: Generar ícono de la app
        script: |
          set -e
          dart run flutter_launcher_icons

      - name: Generar Splash
        script: |
          flutter pub run flutter_native_splash:create

      - name: Compilar APK Release
        script: |
          flutter build apk --release --build-number=${BUILD_NUMBER:-1}
          flutter build appbundle --release --build-number=${BUILD_NUMBER:-1}


      - name: Verificar INTERNET en merged manifest final (build/app)
        script: |
          set -e
          echo "Buscando merged manifest de la APP..."
          find build/app -path "*merged_manifests*" -name "AndroidManifest.xml" -print || true
          MERGED="$(find build/app -path "*merged_manifests*" -path "*release*" -name "AndroidManifest.xml" | head -n 1)"
          echo "MERGED=$MERGED"

          if [ -z "$MERGED" ]; then
            echo "No encontré el merged manifest de la app (build/app)."
            exit 1
          fi

          if grep -q "android.permission.INTERNET" "$MERGED"; then
            echo "OK ✅ El merged manifest de la APP tiene INTERNET."
          else
            echo "ERROR ❌ El merged manifest de la APP NO tiene INTERNET."
            head -n 120 "$MERGED"
            exit 1
          fi


    artifacts:
      - build/app/outputs/flutter-apk/app-release.apk
      - build/app/outputs/bundle/release/app-release.aab
          
